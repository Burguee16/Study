                    QUE ES SQLITE?
Sqlite es una biblioteca en lenguaje C que implementa un motor de base de datos SQL pequeño, rapido, autonomo, de alta confiabilidad
y con todas las funciones. Sqlite es el motor de base de datos mas utilizado en el mundo. SQLite esta integrado en todos los
telefonos moviles y la mayoria de las computadoras y viene incluido en inumerables otras aplicaciones que la gente usa todos los dias.

El formato de archivo SQLite es estable, multiplataforma y compatible con versiones anteriores, y los desarrolladores se comprometen a mantenerlo
asi hasta el año 2050.Los archivos de base de datos SQLite se utilizan habitualmente como contenedores para transferir contenido enriquecido entre
sistemas [1],[2],[3] y como formato de archivo a largo plazo para datos [4]. Hay mas de 1 billon(1e12) de bases de datos SQLite en uso activo.

EL CODIGO FUENTE DE SQLite es de dominio publico y todos pueden usarlo libremente para cualquiera proposito.

                    WHAT IS SQLITE?
SQLite is a C-language library that implements a small, fast, self-contained, high-reliability, full-featured, SQL database
engine. SQLite is the most used database engine in the world. SQLite is built into a mobile phones and most computers and comes
bundled insied countless other applications that people use every day.

The SQLite file format is stable, cross-platform, and backwards compaptible and the developers pledge to keep it that way
trough the year 2050. SQLite database files are commonly used as containers to transfer rich content between systems.[1],[2],[3]
and as a long-term archival formal for data [4]. There are over 1 trillon (1e12) SQLite databases in active use [5].

SQLite sources code is in the public-domain and is free to everyone to use for any purpose.

-------------------------------------------------------------------------------------------------------------------------------------------------

1*TIPOS DE DATOS EN SQLITE
La mayoria de los motores de bases de datos SQL (todos los motores de bases de datos SQL, excepto SQLite, hasta donde sabemos)
utilizan tipado estatico y rigido. Con el tipado estatico, el tipo de datos de un valor esta determinado por su contenedor:
la columna particular en la que se almacena el valor.

SQLite utiliza un sistema de tipos dinamicos mas general. En SQLite, el tipo de datos de un valor esta asociado con el valor en si, no con
su contenedor. El sistema de tupos dinamicos de SQLite es compatible con versiones anterirores de los sistemas de tipos estacicos mas comunes de 
otros motores de bases de datos en el sentido que las sentencias SQL que funcionan en bases de datos con tipos estaticos funcionan de la misma manera
en SQLite.
Sin embargo, el tipado dinamico de SQLite le permite hacer cosas que no son posibles en las bases de datos tradicionales con tipos rigidos. El tipado
flexible es una caracteristica de SQLite, no un error.


1*DATATYPES IN SQLITE
Most SQL database engines(every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing,
the datatype of a value is determined by its container - the particular column in wich the vales is stores.

SQLite uses a more general dynamic type system. In SQLite, the datatype of a values is associated whith the value itself, not with the
value itself, not with its container. The dynamic type system of SQLite is backwards compatible whith the more common static type systems of oher database
engines in the sense that SQL statements that work on statically typed databases work the same way in SQLite. However, the dynamic
typing in SQLite allows it to do things wich are not possible in traditional rigidly typed databases. Flexible typing is a feature of SQLite, not a bug.


2*CLASES DE ALMACENAMIENTO Y TIPOS DE DATOS
Cada valor almacenado en una base de datos SQLite (o manipulado por el motor de base de datos) tiene una de las siguientes clases de almacenamiento:
    **NULL. El valor es un valor NULL.
    **ENTERO. El valor es un entero con un signo almacenado en 0,1,2,3,4,6 u 8 bytes segun la magnitud del valor.
    **REAL. El valor es un valor de punto flotante, almacenado como un numero de punto flotante IEEE de 8 bytes.
    **TEXTO. El valot es una cadena de texto, almacenada utilizando la codificacion de la base de datos (UTF-8, UTF-16BE o UTF-16LE).
    **BLOB. El valor es un blob de datos, almacenado exactamente como fue ingresado.

Una clase de almacenamiento es mas general que un tipo de datos. La clase de almacenamiento INTEGER, por ejemplo, incluye 7 tipos de datos enteros
diferentes de distintas longitudes. Esto marca una diferencia en el disco. Pero tan pronto como los valores INTEGER se leen del disco y se colocan
en la memoria para su procesamiento, se convierten al tipo de datos mas general (entero con signo de 8 bytes). Por lo tanto, en la mayoria de los casos, "clases 
de almacenamiento" es distinguible de "tipo de datos" y los terminos se pueden usar indistintamente.

Cualquier columna de una base de datos SQLite version 3, excepto una columna INTEGER PRIMERY KEY, se puede utilizar par almacerar un valor de cualquier clase de 
almacenamiento.

Todos los valores de sentencias SQL, ya sean literales o integrados en el texto de la sentencia SQL o parametros vinculados a sentencias SQL precompiladas, tienen una 
clase de almacenamiento implicita. En las circunstancias que se describen a continuacion, el motor de base de datos puede convertir valores entre clases de almacenamiento numero
(INTEGER Y REAL) Y TEXT durante la ejecucion de una consulta.

2*STORAGE CLASSES AND DATATYPES
Each value stored in an SQLite databse (or maniupulated by the database engine) has one of the following storage classes:
     **NULL. The value is a NULL value.
     **INTEGER. The value is a signed integer, stored in 0,1,2,3,4,6 or 8 bytes depending on the magnitude of the value.
     **REAL. The value is a floating point value, storedd as an 8-byte IEEE floating point number.
     **TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).
     **BLOB. The value is a blob of data, stored exactly as it was input.

A storage class is more general than a datatype. The INTEGER storage class, for example, includes 7 different integer datatypes of different lengths. This makes a difference on disk.
But as soon as INTEGER values are read off of disk and into memory for processing, they are converted to the most general datatype (8-bte signed integer). And so for the most part, "storage class" is indistinguishable
from "datatype" and the two terms can be used interchangeably.

Any column in an SQLite version 3 database, except and INTEGER PRIMARY KEY column, may be used to store a value of any storage class.

All values in SQL statements, whether they are literals embedded in SQL statement text or parameters bound to precompiled SQL statements have an implicit storage class. Under circumstances described below, the database
engine may convert values between numeric storage classes. (INTEGER and REAL) and TEXT during query execution.

*2.1 TIPO DE DATOS BOOLEANO
SQLite no tiene una clase de almacenamiento booleana independiente. En su lugar, los valores booleanos se almacenan como numeros enteros 0 (falso) y 1 (verdadero).

SQLite reconoce las palabras clave "TRUE" y "FALSE", a partir de al version 3.23.0 (2018-04-02), pero esas palabras clave son en realidad solo graficas alternativas para los literales enteros 1 y 0 respectivamente.

*2.1 BOOLEAN DATATYPE
SQLite does not have a separate Boolean storage class. Instead, Boolean values are stored as integers 0 (false) and 1 (true).

SQLite recognizes the keywords "TRUE" and "FALSE", as of version 3.23.0 (2018-04-02) but those keywords are really just alternative spellings for the integer literals 1 and 0 respectively.

*2.2 TIPO DE DATOS DE FECHA Y HORA
SQLite no tiene una clase de almacenamiento reservada para almacenar fechas y horas. En cambio, las funciones de fecha y hora integradas de SQLite pueden almacenar fechas y horas como valores de TEXTO, REALES o ENTEROS:
    **TEXTO como cadenas ISO8601("AAAA-MM-DD  HH:MM:SS.SSS").
    **REAL como numeros de dias julianos, el numero de dias desde el mediodia en Greenwich el 24 de noviembre de 4714 a.c segun el calendarios gregoriano proleptico.
    **ENTERO como tiempo Unix, el numero de segundos desde 1970-01-01 00:00:00 UTC.

Las aplicaciones puede elegir almacenar fechas y horas en cualqueira de estos formatos y convertir libremente entre formatos utilizando las funciones de fecha y hora integradas.

*2.2 DATE AND TIME DATATYPE 
SQLite does not have a storage class set aside for storing dates and/or times. Instead, the built-in Date ant Time Functions of SQLite are capable of storing dates and times as TEXT,REAL, or INTEGER values:
    **TEXT as ISO8601 strings ("YYYY-MM-DD   HH:MM:SS.SSSS").
    **REAL as Julian day numbers, the number of days since noon in Greenwich on november 24, 4714 B.C. according to the proleptic gregorian calendar.
    **INTEGER as Unix time, the number of seconds since 1970-01-01 00:00:00 UTC.

Applications can choose to store dates and times in any of these formats and freely convert between formats using the built-in date and time functions.

3*TIPO AFINIDAD
Los motores de abses de datos SQL que utilizan tipado rigido generalmente intentaran convertir automaticamente los valores al tipo de datos adecuado. Considere lo siguiente: 
            CREAR TABLA t1 (a INT, b VARCHAR(10));
            INSERTAR EN t1(a,b) VALORES ('123','456);
La base de datos rigidamente tipada convertira la cadena '123' en un entero '123' y el entero 456 en una cadena '456' antes de realizar la insercion.

Para maximizar la compatibilidad entre SQLite y otros motores de bases de datos, y para que el ejemplo anterior funcione en SQLite como lo hacen en otros motores de bases de datos SQL,
SQLite admite el concepto de "afinidad de tipo" en las columnas. La afinidad de tipo de una columna es el tipo recomendado para los datos almacenados en esa columna. La idea importante aqui es que el tipo es recomendado,
no obligatorio. Cualquier columna puede almacenar cualquier tipo de datos. Es solo usar una clase de almacenamiento en lugar de otra. La clase de almacenamiento preferida para una columna se llama "afinidad".

A cada columna de una base de datos SQLite 3 se le asigna una de las siguientes afinidades de tipo: 
    **TEXTO
    **NUMERICO
    **ENTERO
    **REAL
    **GOTA
(Nota historica: La afindad de tipo "BLOB" solia llamarse "NONE". Pero este termino era facil de confundir con "sin afinidad", por lo que se le cambio el nombre.

Una columna con afinidad TEXT almacena todos los datos utilizando las clases de almacenamiento NULL, TEXT o BLOB. Si se insertan datos numericos en una columna con afinidad TEXT, se convierten a formato de texto antes de almacenarlos .

Una columna con afinidad NUMERICA puede contener valores que utilicen las cinco clases de almacenamiento. Cunado se insertan datos de texto en una columna NUMERICA, la clase de almacenamiento de texto se convierte a INTEGER o REAL (en orden
de preferencia) si el texto es un literal real o entero bien formado,
respectivamente. Si el valor TEXT es un literal entero bien formado que es demasiado grande para caber en un entero con signo de 64 bits, se convierte a REAL. Para las conversiones entre las clases de almacenamiento TEXT y REAL, solo se 
conservan los primeros 15 digitos decimales significativos del numero. Si el valor TEXT no es un literal real o entero bien formado, entonces el valor se almacena como text. Para
los fines de este parrafo, los literales enteros hexadecimales no se consideran bien formados y se almacenan como TEXT. (Esto se hace por compatibilidad historica con versiones de SQLite anteriores a la version 3.8.6 2014-08-15 donde los literales 
enteros hexadecimales se introdujeron por primera vez en SQLite).
Si se inserta un valor de punto flotanto que se puede representar exactamente como un entero en una columna con afinidad NUMERICA, el valor se convierte en un entero.
No se intenta convertir valores NULL o BLOB.

Una cadena puede parecer un literal de punto flotante con un punto decimal y/o notacion de exponente, pero siempre que el valor pueda expresarse como un entero, la afinidad NUMERICA
lo convertira en un entero. Por lo tanto, la cadena '3.0e+5' se almacena en una columna con afinidad NUMERICA como el entero 300000, no como el valor de punto flotante 300000.0.

Una columna con afinidad REAL se comporta como una columna con afinidad NUMERICA, excepto que fuerza los valores enteros a una representacion de punto flotante. (Como optimizacion interna, los valores de punto flotante pequeños sin componente 
fraccionario y almacenados en columnas con afinidad REAL se escriben en el disco como enteros para ocupar menos espacio y se convierten automaticamente de nuevo a punto flotante a medida que se lee el valor. Esta optimizacion es completamente 
invisible a nivel de SQL y solo se puede detectar examinando los bits sin procesar del archivo de base de datos).

*TYPE AFFINITY 
SQL database engines that use rigid typing will usually try to automatically convert values to the appropiate datatype. Consider this:
      CREATE TABLE t1(a INT, b VARCHAR(10));
      INSERT INTO t1(a,b) VALUES ('123','456');
Rigidly-typed database will convert the string '123' into an integer 123 and the integer 456 into a string '456' prior to doing the insert.

In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines,
SQLite supports the concept of "type affinity" on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any 
type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its "affinity".

Each column in an SQLite 3 database is assigned one of the following type affinities:
    *TEXT
    *NUMERIC
    *INTEGER
    *REAL
    *BLOB
(Historical note: The "BLOB" type affinity used to be called "NONE". But that term was easy to confuse with "no affinity" and so it was renamed.)

A column with TEXT affinity stores all data using storage classes NULL, TEXT or BLOB. If numerical data is inserted into a column with TEXT affinity it is converted into text form before being stored.

A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL(in order of preference) if the text is a well-formed integer 
or real literal, respectively. If the TEXT value is a well-formed integer literal that is too large to fit in a 64-bit signed integer, it is converted to REAL. For conversions between TEXT and REAL storage classes, only the first 15 significant decimal digits of the 
number are preserved. If the TEXT value is stored as TEXT.For the pirposes of this paragraph, hexadecimal integer literals are not considered well-formed and are stored as TEXT. (This is for historical compatibility
with versions of SQLite prior to version 3.8.6 2014-08-15 where hexadecimal integer literals were first introduced into SQLite.) If a floating point value that can be represented exactle as and integer is inserted into a column with NUMERIC affinity,
the value is converted into as integer. No attempt is made to convert NULL or BLOB values.

A string migth look like a floating-point literal with a decimal point and/or exponent notation but as long as the value can be expressed as integer, the NUMERIC affinity will convert it into an integer. Hence, the 
string '3.0e+5' is stored in a column with NUMERIC affinity, the value is converted into an integer 300000, not as the floating point value 30000.0.

A column that uses INTEGER affinity behaves the same as a column with NUMERIC affinity. The difference between INTEGER and NUMERIC affinity is only evident in a CAST expression: The expression "CAST(4.0 AS INT)" returns and integer 4, whereas "CAST(4.0 
AS NUMERIC)" leaves the values as a floating-point 4.0.

A column with REAL affinity behaves like a column with NUMERIC affinity except that it forces integer values, into floating point representation. (As an internal optimization, small floating point values with no fractional component and stored in columns
with REAL affinity are written to disk as integer in order to take up less space and are automatically converted back into floating point as the value is read out. This optimization is completely invisible at the SQL level and can only be detected by examining the raw
bits of the database file.)

A column with affinity BLOB does not prefer one storage class over another and no attempt is made to coerce data from one storage cllas into another.

*3.1 DETERMINACION DE LA FINIDAD DE LA COLUMNA
Para las tablas no declaradas como STRICT, la afinidad de la columna no esta determinada por el tipo declarado de la columna, de acuerdo con las siguientes reglas en el orden que se muestra:
  1. Si el tipo declarado contiene la cadena "INT", entonces se le asigna la afinidad INTEGER.
  2. Si el tipo declarado de la columna contiene cualquiera de las cadenas "CHAR", "CLOB" o "TEXT", entonces esa columna tiene afinidad TEXT. Observe que el tipo 
VARCHAR contieen la cadena "CHAR" y, por lo tanto, se le asigndad la afinidad TEXT.
  3. Si el tipo declarado para una columna contiene la cadena "BLOB" o si no se especifica ningun tipo entonces la columna tiene
afinidad BLOB.
  4. Si el tipo declarado para una columna contiene cualquiera de las cadenas "REAL, "FLOA", o "DOUB", entonces la columna
tiene afinidad REAL.
  5. De lo contrario, la afinidad es NUMERICA.

Tenga en cuenta que el orden de las reglas para determinar la afinidad de las columnas es importante. Una columna cuyo tipo declarado
sea "CHARINT" coincidira con las reglas 1 y 2, pero la primera regla tendra prioridad y, por lo tanto, la afinidad de la columna sera INTEGER.

*3.1 DETERMINATION OF COLUMN AFFINITY
For tables not declared as STRICT, the affinity of a column is determined by the declared type of the column, 
accoirding to the following rules in the order shown:
  1. If the declared type contains the string "INT" then it is assigned INTEGER affinity.
  2. If the declared type of the column contains any of the strings "CHAT", "CLOB", or "TEXT" the that column has TEXT
affinity. Notice that the type VARCHAR contatins the string "CHAR" and is thus assinged TEXT affinity.
  3. If the declared type for a column contains the string "BLOB" or if no type is specified the the colunm has affinity BLOB.
  4. If the declared type for a column contains any of the string "REAL", "FLOA", or "DOUB" then the column has REAL affinity.
  5. Otherwise, the affinity is NUMERIC.

Note that the order of the rules for defermining column affinity is important. A column whose declared type is "CHARINT" will match both rules 
1 and 2 but the first rule takes precedence so the column affinity will be INTEGER.

*3.1.1 EJEMPLOS DE NOMBREES DE AFINIDAD
La siguiente tabla muestra cuantos nombres de tipos de datos comunes de implementaciones SQL mas tradicionales se convierten
en afinidades mediante las cinco reglas de la seleccion anterior. Esta tabla muestra solo un pequeño subconjunto de los nombres de tipos
de datos que SQLite aceptara. Tenga en cuenta que SQLite ignora los argumentos numericos entre parentesis que siguen
al nombre del tipo (por ejemplo "VARCHAR(255)"); SQLite no impone ninguna restriccion de longitud (exepto el gran limite
goblal SQLITE MAX LENGTH) sobre la longitud de cadenas, BLOB o valores numericos.

EJ NOMBRES DE TIPOS DE DECLARACION        AFINIDAD RESULTANTE           REGLA UTILIZADA PARA DETERMINAR
CREATE TABLE O LA EXPRESION CAST                                        AFINIDAD
   *INT                                   ENTERO                            1
   *ENTERO                                ENTERO                            1
   *PEQUEÑO                               ENTERO                            1
   *INT PEQUEÑO INT                       ENTERO                            1
   *MEDIO INT GRANDE SIN SIGNO            ENTERO                            1
INT GRANDE INT2 INT 8


   *CHARACTER(20)                         TEXTO                            2
   *VARCHAR(255)                          TEXTO                            2
   *CHRACTER                              TEXTO                            2
   *VARYING(255)                          TEXTO                            2
   *NCHAR(55)                             TEXTO                            2
   *CHARACTER NATIVE(70)                  TEXTO                            2
   *NVCHAR(100)                           TEXTO                            2
   *TEXTO                                 TEXTO                            2
   *CLOB                                  TEXTO                            2
       


   *BLOB                                  GOTA                             3
(Sin tipo de datos especificado)

   *FLOTADOR DE PRECISION                 REAL                             4
DOBLE DOBLE REAL

   *NUMERICO                              NUMERICO                         5
   *DECIMAL(10,5)                         NUMERICO                         5
   *BOOLEAN                               NUMERICO                         5
   *FECHA                                 NUMERICO                         5
   *FECHAHORA                             NUMERICO                         5


Tengan en cuenta que un tipo declarado de "PUNTO FLOTANTE" daria afinidad de ENTERO, no de REAL, debido al
"INT" al final de un "PUNTO". Y el tipo declarado de "CADENA" tiene una afinidad de NUMERICO, no de TEXTO.

*3.1.1 AFFINITY NAME EXAMPLES
The following table shows how many common datatype names from more traditional SQL implementations are converted
into affinities by the file rules of the previous section. This table shows only a slmall subset of the datatype
names that SQLite will acept. Note that numeric argument in parentheses that following the type name (ex:"VARCHAR(255)")
are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global SQLITE MAX LENGTH
limit) on the length of strings, BLOBs or nunmeric values.


EXAMPLESTYPENAMES FROM   THE              RESULTING AFFINITY          RULE USED TO DETERMINE AFFINITY
CREATE TABLE STATEMENT OR CAST EXPRESION                                       
   *INT                                                                    1
   *INTEGER                               INTEGER                          1
   *TINYINT                               INTEGER                          1
   *SMALLINT                              INTEGER                          1
   *BIGINT                                INTEGER                          1
   *UNSIGNED BIG INT                      INTEGER                          1
   *INT2                                  INTEGER                          1
   *INT8                                  INTEGER                          1


   *CHARACTER(20)                         TEXT                             2
   *VARCHAR(255)                          TEXT                             2
   *VARYING CHARACTER(255)                TEXT                             2
   *NCHAR(55)                             TEXT                             2
   *NATIVE CHARACTER(70)                  TEXT                             2
   *NVCHAR(100)                           TEXT                             2
   *TEXT                                  TEXT                             2
   *CLOB                                  TEXT                             2
       


   *BLOB                                  BOLOB                           3
(no datatype specified)

   *REAL                                  REAL                            4
   *DOUBLE                                REAL                            4
   *DOUBLE PRECISION                      REAL                            4
   *FLOAT                                 REAL                            4
 
   *NUMERIC                               NUMERIC                         5
   *DECIMAL(10,5)                         NUMERIC                         5
   *BOOLEAN                               NUMERIC                         5
   *DATE                                  NUMERIC                         5
   *DATETIME                              NUMERIC                         5

Note that a declared type of "FLOATING POINT" would give INTEGER affinity, not REAL affinity, due to the "INT"
at the end of "POINT". And the declared type of "STRING" has an affinity of NUMERIC, not TEXT.

*3.2 AFINIDAD DE EXPRESIONES
Cada columna de la tabla tiene una afinidad de tipo (una de BLOB, TEXT, INTEGER, REAL o NUMERIC), pero las
expresiones no necesariamente tienen una afinidad.

La afinidad de expresion esta determinada por las siguientes reglas:
  *El operando derecho de un operador INT o NOT INT no tiene afinidad sin el operando es una lista, o tiene
la misma afinidad que la expresion del conjunto de resultados si el operando es un SELECT.
  *Cuando una expresion es una referencia simple a una columna de una tabla real ( no una VISTA o subconsulta),
entonces la expresion tiene la misma afinidad que la columna de la tabla.
       .Los parentesis que rodean el nombre de la columna se ignoran. Por lo tanto, si X e YZ son nombres
        de columnas , (X) e (YZ) tambien se consideran nombres de columnas y tienen la misma afinidad de
        las columnas correspondientes.
       .Cualquier operador aplicado a los nombres de columnas, incluido el operador uniario "+", convierte el 
        nombre de la columna en una expresion que nunca tiene afinidad.  Por lo tanto, incluso si X e YZ son 
        nombres de columnas, las expresiones +X y +YX no son nombres de columnas y no tienen afinidad.
  *Una expresion de la forma "CAST( exp AS type)" tiene una afinidad que es la misma que una columna de tipo 
declarado de "type".
  *Un operador COLLATE tiene la misma afinidad que su operando del lado izquierdo.
  *De lo contrario, una expresion no tiene afinidad.

*3.2 AFFINITY OF EXPRESSIONS
Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do not 
necessary have an affinity.

Expression affinity is determined by the following rules:
  *The rigth-hand operand of an INT or NOT INT operator has no affinity if the operand is a list, or has
the same affinity as the affinity of the result set expression if the operand is a SELECT.
  *When an expression is a simple reference to a column of a real table (not a VIEW of subquery) then the
expression has the same affinity as the table column.
        .Parentheses around the column name are ignored. Hence if X and Z.Y are columns names, then (X) and 
        (Y.Z) are also considered column names and have the affinity of the corresponding cloumns.
        .Any operators applied to column names, including the no-op unary "+" operator, convert the column
        name into an expression wich always has no affinity. Hence even if X and Y.Z are column names, the
        expressions +x and +Y.Z are not columns names and have no affinity.
  *An expression of the form "CAST(expr AS type)" has an affinity that is the same as a column with a declared type
of "type".
  *A COLLATE operator has the same affinity as its left-hand side operand.
  *Otherwise, an acpression has no affinity.

*3.3 AFINIDAD DE COLUMNAS PARA VISTAS Y SUBCONSULTAS
Las "columnas" de una subconsulta de clausula FROM o VIEW son en realidad las expresiones del conjunto de resultados de la sentencia
SELECT que implementa la clausula FROM o VIEW. Por lo tanto, la afinidad de las columnas de una clausula FROM
o VIEW se determina mediante las reglas de afinidad de expresiones anteriores. Considere un ejemplo:
      CRETE TABLE t1( a INT, b TEXTO, c REAL);
      CREATE VIST v1(x,y,z) COMO SELECCIONAR b, a+c, 42 de t1 WHERE b!=11;
La afinidad de la columna v1.x sera la misma que la afinidad de t1.b (TEXT), ya que v1.x se asigna directamente
a t1.b. Pero las columnas v1 y y v1.z no tienen afinidad, ya que esas columnas se asignan a la expresion a+c y 42,
y las expresiones siempre no tienen afinidad.

*3.3 COLUMN AFFINITY FOR VIEWS AND SUBQUERYS
The "columns" of a VIEW or FROM-clause subquery are really the expressions in the result set of the SELECT
statement that implements the VIEW of subquery. Thus, the affinity for columns of a VIEW or subquery are determined
by the expression affinity rules above.
Consider an example: 
     CREATE TABLE T1(a INT, b TEXT, c REAL);
     CREATE VIEW v1(x,y,z) AS SELECT b, a+c, 42 FROM t1 WHERE b!=11;
The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT), since v1.x maps directly into t1.b.
But columns v1.y and v1.z both have no affinity, since those columns map into expression a+c and 42, and expressions always have no affinity.

*3.3.1 AFINIDAD DE COLUMNAS PARA VISTAS COMPUESTAS
Cuando la sentencia SELECT que implementa una subconsulta de clausula FROM o VIEW es una SELECT compuesta, la afinidad de cada columna
de la VIEW o subconsulta sera la afinidad de la columna de resultado correspondiente para una de las sentencias SELECT individuales que
conforman la compuesta. Sin embargo, no se puede determinar cual de las sentencias SELECT se utilizara para determinar la afinidad. Se pueden 
utilizar distintas sentencias SELECT constituyentes para determinar la afinidad en distintos momentos durante la evaluacion de la consulta.
La  eleccion puede variar en distintas versiones de SQLite. Lae eleccion puede cambiar entre una consulta y la siguiente en la misma version de
SQLite. La eleccion puede ser diferente en distintos momentos dentro de la misma consulta. Por lo tanto, nunca se puede estar seguro de que 
afinidad se utilizara para las columnas de una SELECT compuesta que tienen distintas afinidades en las subconsultas constituyentes.

La mejor practica es evitar mezclar afinidades en una seleccion compuesta si le interesa el tipo de datos del resultado. Mezclar afinidades en una
seleccion compuesta puede generar resultados sorprendentes y poco intuitivos.

*3.3.1 COLUMN AFFINITY FOR COMPOUND VIEWS
When the SELECT statement that implements a VIEW or FROM-clause subquery is a compound SELECT then the affinity of each column of the VIEW
or subquery will be the affinity of the corresponding result column for one of the individual SELECT statements that make up the compound.
However, it is indeterminate wich of the SELECT statements will be used to determinate affinity. Different constituent SELECT statements migth be used 
to determinate affinity at different times during query evaluation. The choice migth vary across different versions of SQLite. The choice migth change
between one query and the next in the same version of SQLite. The choice migth be different at different times within the same query. Hence, you can never 
be sure what affinity will be used for columns of a compound SELECT that have different affinities in the constituent subqueries.

Best practice is to avoid mixin affinities in a compound SELECT if you care about the datatype of the result. Mixing affinities in a compound SELECT can lead to surprising and unituitive results.

*3.4 EJEMPLO DE COMPORTAMIENTO DE AFINIDAD DE COLUMNAS
El siguien SQL demuestra como SQLite usa la afinidad de columnas para realizar conversiones de tipos cuadno se insertan valores en una tabla.
          CREAR TABLA t1(
               t TEXTO, -- afinidad de texto por regla 2
               nu NUMERIC, -- afinidad numerica por regla 5
               i ENTERO, -- afinidad de enteros por regla 1
               r REAL, -- afinidad real por regla 4
               Sin BLOB: sin afinidad segun la regla 3
           );
*3.4 COLUMN AFFINITY BHAVIOR EXAMPLE
The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.
         CREATE TABLE t1(
                 t TEXT, -- text affinity by rule 2
                 nu NUMERIC, -- numeric affinity by rule 5
                 i INTEGER, -- integer affinity by rule 1
                 r REAL, -- real affinity by rule 4
                 no BLOB -- no affinity by rule 3
             );
*4 EXPRESIONES DE COMPARACION
La version 3 de SQLite tiene el conjunto habitual de operadores de comparacion de SQL, incluidos "=", "==","<", ">", "<=", ">=","!=","",
"IN", "NOT IN", "BETWEEN", "IS" y "IS NOT".

4*COMPARISON EXPRESSIONS
SQLite version 3 has the usual set of SQL comparison operators including "=", "==", "<", "<=", ">", ">=", "!=", "", "IN", "NOT IN", "BETWEEN", "IS", and "IS NOT", .

*4.1 ORDEN DE CLASIFICACION
Los resultados de una comparacion dependen de las clases de almacenamiento de los operandos, de acuerdo con las siguientes reglas:
   *Un valor con clase de almacenamiento NULL se considera menor que cualquier otro valor (incluido otro valor con clase 
    de almacenamiento NULL.
   *Un valor ENTERO o REAL es menor que cualquier valor de TEXTO o BLOB. Cuando se compara un ENTERO o REAL con otro ENTERO o REAL, se realiza
    una comparacion numerica.
   *Un valor de TEXTO es menor que un valor de BLOB. Cuando se comparan dos valores de TEXTO, se utiliza una secuencia de cotejo adecuada para
    determinar el resultado.
   *Cuando se comparan dos valores BLOB, el resultado se determinar utilizando memcmp().

*4.1 SORT ORDER
The results of a comparison depend on the storage classes of the operands, according to the following rules:
   *A value with storage class NULL is considered less than any other value (including another value with storage class NULL).
   *An INTEGER or REAL value is less than any TEXT or BLOB value. When an INTEGER or REAL is compared to another INTEGER or REAL, a numerical 
   comparison is performed.
   *A TEXT value is less than a BLOB value. When two TEXT values are compared an appropiate collating sequence is used to determine the result.
   *When two BLOB values are compared, the result is determined using memcmp().

*4.2 CONVERSIONES DE TIPOS ANTES DE LA COMPARACION
SQLite puede intentar convertir valores entre las clases de almacenamiento INTEGER, REAL y/o TEXT antes de realizar una comparacion. El hecho de 
que se intenten o no conversiones antes de que se realice la comparacion depende de la afinidad de tipo de los operandos.

"Aplicar afinidad" significa convertir un operando en una clase de almacenamiento particular si y solo si la conversion no pierde informacion esencial.
Los valores numericos siempre se pueden convertir en TEXTO. Los valores de TEXTO se pueden convertir en valores numericos si el contenido de texto
es un entero bien formado o un literal real, pero no un literal entero hexadecimal. Los valores BLOB se convierten en valores de TEXTO simplemente
interpretando el contenido binario BLOB como una cadena de texto en la codificacion de base de datos actual.

La afinidad se aplica a los operandos de un operador de comparacion antes de la comparacion de acuerdo con las siguientes reglas en el orden que se muestra:
  *Si un operando tiene afinidad ENTERA, REAL o NUMERICA y el otro operando tiene TEXTO o BLOB o no tiene afinidad, entonces se aplica afinidad
   NUMERICA al otro operando.
  * Si un operando tiene afinidad de TEXTO y el otro no tiene afinidad, entonces se aplica la afinidad de TEXTO al otro operando.
  *De lo contrario, no se aplica ninguna afinidad y ambos operandos se comparan tal como estan.

La expresion "a BETWEEN b AND c" se trata como dos comparaciones binarias independientes "a >= b AND a <= c", incluso si eso significa que se aplican
diferentes afinidades a 'a' en cada una de las comparaciones. Las conversiones de tipos de datos en comparaciones de la forma "x IN (SELECT y...)" se 
manejan como si la comparacion fuera realmente "x=y". La expresion "a IN  (x,y,z...)" es equivalente a "
a = +x OR a = +y OR a = +z OR...". En otras palabras, los valores de la derecha del operador IN (los valores "x","y" y "z" en este ejemplo) se consideran 
sin afinidad, incluso si resultan ser valores de columna o expresiones CAST.

*4.2 TYPE CONVERSIONS PRIOR TO COMPARISON
SQLite may attempt to convert values between the storage classes INTEGER, REAL, and /or TEXT before performing a comparison. Whether or not any conversions
are attempted before the comparison takes place depends on the type affinity of the operands.

To "apply affinity " means to convert an operand to a particular storage class if and only if the conversion does not lose essential information. Numeric
values can always be converted into TEXT. TEXT values can be converted into numeric values if the text content is a well-formed integer or real literal,
but not a hexadecimal integer literal. BLOB values are converted into TEXT values by simply interpreting the binary BLOB content as a text string in the current
database encoding.

Affinity is applied to operands of a comparison operator prior to the comparison according to the following rules in the order shown:
  *If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.
  *If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.
  *Otherwise, no affinity is applied and both operands are compared as is.

The expression "a BETWEEN b AND c" is treated as two separate binary comparisons "a<=b AND a<=c", even if that means different affinities are applied to 'a' in
each of the comparisons. Datatype conversions in comparisons of the form "x IN (SELECT y...)" are handled as if the comparison were really "x=y". The expression
"a IN (x,y,z, ...)" is equivalent to "a = +x OR a =+y OR a = +z OR ...". In other words, the values to the rigth of the IN operator (the "x", "y" and "z" values
in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.

*5 OPERADORES
Los operadores matematicos (+,-,etc) intrpretan ambos operandos como si fueran numeros. Los operados STRING o BLOB se convierten automaticamente en valores
REAL o INTEGER. Si el STRING o BLOB parece un numero real (si tiene un punto decimal o un exponente) o si el valor esta fuera del rango 
que se puede representar como un entero con signo de 64 bits, entonces se convierte en REAL. De lo contrario, el operando se convierte en INTEGER. La conversion
de tipo implicita de los operandos matematicos es ligeramente diferente de CAST a NUMERIC en que los valores de cadena y BLOB que parecen numeros reales pero no
tienen una parte fraccionaria se mantienen como REAL  en lugar de convertise en INTEGER como seria para CAST a NUMERIC. La conversion de STRING o BLOB a REAL o
INTEGER se realiza incluso si es con perdida e irreversible. Algunos operadores matematicos esperan operandos INTEGER. Para esos operadores, los operandos REAL
se convierten en INTEGER de la misma manera que un CAST a INTEGER. Los operadores <<,>> & y | siempre devuelven un resultado INTEGER (o NULL), pero el operador
% devuelve INTEGER o REAL (O NULL) segun el tipo de sus operandos. Un operando NULL en un operador matematico produce un resultado NULL. Un operando en un operador 
matematico que no parece numerico de ninguna manera y no es NULL se convierte a 0 0.0. La division por cero da como resultado NULL.

*5 OPERATORS 
Mathematical operators(+,-,etc) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values.
If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as
a 64-bit signed integer, the it converts to REAL. Othewise the operand converts to INTEGER. The implied type conversion of  mathematical operands is slightly different
from CAST to NUMERIC in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into
INTEGER as they would be for CAST to NUMERIC. The conversion from STRING or BLOB int REAL or INTEGER is performed eve if it is lossy and irreverible. Some mathematical
operators  expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a CAST to INTEGER. The <<,>> & and | operators always
return an INTEGER (or NULL) result. An operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way 
numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.

*6 ORDENACION, AGRUPACION Y SECLECT COMPUESTOS
Cuando los resultados de una consulta se ordenan mediante una clausula ORDER BY, los valores con la clase de almacenamiento NULL aparecen primero, seguidos de los valores
INTEGER  y REAL intercalados en orden numerico, seguidos de valores TEXT en orden de secuencia de intercalacion y, por ultimo, los valores BLOB en orden memcmp(). No se producen 
conversiones de clase de almacenamiento antes de la ordenacion.

Al agrupar valores con la clausular GROUP BY, los valores con diferentes clases de almacenamiento se consideran distintos, excepto los valores INTEGER y REAL, que se consideran
iguales si son numericamente iguales. No se aplican afinidades a ningun valor como resultado de una clausula GROUP BY.

Los operadores SELECT compuestos UNION, INTERSECT y EXCEPT realizan comparaciones implicitas entre valores. No se aplica ninguna afinidad a los operandos de comparacion
para las comparaciones implicitas asociadas con UNION, INTERSECT o EXCEPT: los valores se comparan tal como estan.

*6 SORTING, GROUPING AND COMPOUNDS SELECTS 
When query results are sorted by an ORDER BY clause, values with storage class NULL come first, followed by INTEGER and REAL values interspersed in numeric order, followed by TEXT values 
in collating sequence order, and finally BLOB values in memcmp() order. No storage class conversions occur before the sort.

When grouping values with the GROUP BY clause values with different storage classes are considered distinct, except for INTEGER and REAL values wich are considered equal if they are 
numerically equal. No afiinities are applied to any values as the result of a GROUP by clause.

The compound SELECT operators UNION, INTERSECT and EXCEPT  perform implicit comparisons between values. No affinity is apllied to comparison operands for the implicit comparisons associated with UNION, 
INTERSECT, or EXCEPT - the values are compared as is.

7* RECOPILACION DE SECUENCIAS
Cuando SQLite compara dos cadenas, utiliza una secuencia de intercalacion o una funcion de intercalacion (dos terminos para lo mismo) para determinar que cadena es mayor o si las dos cadenas
son iguales. SQLite tiene tres funciones de intercalacion integradas : BINARY, NOCASE Y RTRIM.
    *BINARIO: Comprada datos de cadena utilizando memcmmp(), independientemente de la codificacion del texto.
    *NOCASE: similar al binario, excepto que utiliza sqlite3 strincmp(). para la comparacion. Por lo tanto, los 26 caracteres en mayusculas de ASCII se convierten en sus equivalentes en minusculas
    antes de realizar la comparacion. Tenga en cuenta que solo se convierten en mayusculas los caracteres ASCCII. 
    SQLite no intenta realizar la conversion completa de mayusculas y minusculas en UTF debido al tamaño de tablas requeridas. Tenga en cuenta tambien que cualquier caracter U+0000 en la cadena
    se considera un terminador de cadena para fines de comparacion.
    *RTRIM: Lo mismo que el binario, excepto que se ignoran los caracteres de espacio finales.

Una aplicacion puede registrar funciones de intercalacion adicionales utilizando la interfaz sqlite3 create collation().

Las funciones de intercalacion solo son importantes cuando se comparan valores de cadena. Los valores numericos 
siempre se comparan numericamente y los BLOB siempre se comparan byte a byte mediante memcmp().

*7 COLLATING SEQUENCES
When SQLite compares two strings, it uses a collating sequence or collating function (two terms for the same thing) to determine wich string
is greater or if the two strings are equal. SQLite has three built-in collating functions: BINARY, NOCASE and RTRIM.
   *BINARY - Compares string data using memcmp(), regardless of text encoding.
   *NOCASE - Similar to binary, except that it uses sqlite3 strnicmp(). for the comparison. Hence the 26 upper case
   characters of ASCII are folded to their lower case equivalents before the comparison is performed. Note that only ASCII characters
   are case folder. SQLite does not attempt to do full UTF case folding due to the size of the tables required. Also note that any U+0000
   characters i the string are considered string terminators for comparison puposes.
   *RTRIM - The same as binary, except that trailing space characters are ignored.

An application can register additional collating functions using the sqlite3 create collation(). interface.

Collating functions only matter when comparing string values. Numeric values are always compared numerically, and BLOBs are always
compared byte-by-byte using memcmp().

*7.1 ASINGNACION DE SECUENCIAS DE INTERCALACION DESDE SQL
Cada columna de cada tabla tiene una funcion de intercalacion asociada. Si no se definde explicitamente ninguna funcion de intercalacion, la funcion
de intercalacion predeterminada es BINARY. La clausula COLLATE de la defincion de columna se utiliza para definir funciones de intercalacion 
alternativas para una columna.

Las reglas para determinar que funcion de comparacion utilizar para un operador de comparacion binaria son las siguientes:
   1.- Si alguno de los operandos tiene la asignacion de funcion de comparacion explicita utilizando el operador sufijo COLLATE, entonces se utiliza
la funcion de comparacion explicita para la comparacion del operando izquierdo.
   2.- Si alguno de los operandos es una columna, se utiliza la funcion de ordenacion de esa columna con prioridad sobre el operando izquierdo. A los 
efectos de la oracion anterior, un nombre de columna procedido por uno o mas operadores unarios "+" y/o operadores CAST se sigue considerando un
nombre de columna.
   3.- De lo contrario, se utiliza la funcion de comparacion BINARY.

Se considera que un operando de una comparacion tiene una asignacion de funcion de intercalacion explicita (regla 1 anterior) si alguna subexpresion del operando
utiliza el operador COLLATE de posfijo. Por lo tanto, si se utiliza un operador COLLATE en cualquier parte de una expresion de comparacion, la funcion de intercalacion
definida por ese operador se utiliza para la comparacion de cadenas independientemente de que columnas de la tabla puedan ser parte de esa expresion. Si aparecen
dos o mas subexpresiones del operador COLLATE en cualquier parte de una comparacion, se utiliza la funcion de intercalacion explicita mas a la izquierda independientemente
de cuan profundamente esten anidados los operadores COLLATE en la expresion e independientemente de como este entre parentesis la expresion

La expresion "x ENTRE y y <" es logicamernte equivalente a dos comparacines "x >= y AND x <=z " y funciona con respecto a las funciones de cotejo como si fueran dos
comparaciones separadas. La expresion "x IN (SELECT y...)" se maneja de la mimsma manera que la expresion "x=y" a los efectos de determinar la secuencia de cotejo. La 
secuencia de cotejo utiliza para expresiones de la forma "x IN (z,y,...)" es la secuencia de cotejo explicita de un operador IN, se debe aplicar al operando izquierdo, de esta
manera: "x COLLATE nocase IN (y,z...)".

A los terminos de la clausula ORDER BY que forman parte de una instruccion SELECT se les puede asignar una secuencia de ordenacion mediante el operador COLLATE, en cuyo caso 
se utiliza la funcion de ordenacion especificada. De lo contrario, si la expresion ordenada por una clausula ORDER BY es una columna, se utiliza la secuencia de ordenacion de la
columna para determinar el orden de clasificacion. Si la expresion no es una columna y no tiene una clausula COLLATE, se utiliza la secuencia de ordenacion BINARY.

*7.1 ASSIGNING COLLATING SEQUENCES FROM SQL
Every column of every table has an associated collating function. If no collating function is explicitly defined, then the collating function defaults to BINARY. The COLLATE
clause of the column definition is used to define alternative collating functions for a column.

The rules for determining wich collating function to use for a binary comparison operator are as follows:
   1.- If either operand has an explicit collating function assignment using the postfix COLLATE operator, then the explicit collating function is used for comparison, with
precedence to the collating function of the left operand.
   2.- If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previus sentence, a column
name prceded by one or more unary "+" operators and/or CAST operators is still considered a column name.
   3.- Otherwise, the BINARY collating functions is used for comparison.

An operand of a comparison is considered to have an explicit collating function assignment(rule 1 above) if any suubexpression of the operand uses the postfix COLLATE operator. 
Thus, if a COLLATE operator is used anywhere in a comparison expression, the collating function defined by that operator is used for string comparison regardless of what table 
columns migth be a part of that expression. If two or more COLLATE operator subexpressions appear anywhere in a comparison, the left most explicit collating function is ued regardless of how 
deeply the COLLATE operators are nested in the expression and regardless of how the expression is parenthesized.

The expression "x BETWEEN y  an z" is logically equivalent to two camparisons "x >= y AND x<= <" and works with respect to collating functions as if it were two separate comparisons.
The expression "x IN (SELECT y...)" is handled in the same way as the expression "x = y" for the puposes of determining the collating sequence. The collating sequence used for 
expressions of the form "x IN (y,z,...)" is the collating sequence of x. If an explicit collating sequence is required on an IN operator it should be applied to the left operand,
like this: "x COLLATE nocase IN (y,z,...)".

Terms of the ORDER BY clause that is part of a SELECT statement may be assigned a collating sequence using the COLLATE operator, in wich case the specified collating function is 
used for sorting. Otherwise, if the expression sorted by and ORDER BY clause is a column, then the collating sequence of the column is used to determine sort order. If the expression 
is not a column and has no COLLATE clause, then the BINARY collating sequence is used.